<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<chapter id="introduction">

<title>Introduction</title>

<para>This document describes the APIs provided by
<ulink url="http://librdf.org/raptor/">Raptor</ulink> to
turn syntaxes into RDF triples and RDF triples into syntaxes.</para>

<para>See also the <ulink url="http://librdf.org/raptor/">Raptor Home Page</ulink>
and the <ulink url="../README.html">main document overview</ulink>.
</para>


<section id="initialising-finishing">
<title>Initialising and Finishing using the Library</title>

<para>The raptor library has a single initialising function and a
single terminating function.  These must be called before any other
Raptor API functions are called:
<programlisting>
  raptor_init();
  ...
  raptor_finish();
</programlisting>
</para>

<para>It is safe to call these functions more than once.  But don't
do that!</para>

</section>


<section id="querying-functionality">
<title>Querying Functionality</title>

<para>
Raptor can be configured and compiled with support for different
parsers and serializers.  Lists of the functionality built into the
library can be interrogated by means of
<emphasis>enumerate</emphasis> functions.  These take as input an
<literal>int</literal> counter and return descriptions of the feature
at that offset in the list.  The return value of the function
is non-zero when the counter has gone too far.
</para>

<variablelist>
<title>Listing Functionality with Enumeration</title>
<varlistentry><term>List the parse syntaxes (parser names)</term>
<listitem><programlisting>
int
raptor_parsers_enumerate(const unsigned int counter,
                         const char **name, const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the parse syntaxes
(same as above but with more information)</term>
<listitem><programlisting>
int
raptor_syntaxes_enumerate(const unsigned int counter,
                          const char **name,
                          const char **label, 
                          const char **mime_type,
                          const unsigned char **uri_string);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the serializer syntaxes (serializer names)</term>
<listitem><programlisting>
int
raptor_serializers_enumerate(const unsigned int counter,
                             const char **name,
                             const char **label,
                             const char **mime_type,
                             const unsigned char **uri_string);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the Parser features</term>
<listitem><programlisting>
int
raptor_features_enumerate(const raptor_feature feature,
                          const char **name, raptor_uri **uri,
                          const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the Serializer features</term>
<listitem><programlisting>
int
raptor_serializer_features_enumerate(const raptor_feature feature,
                                     const char **name,
                                     raptor_uri **uri,
                                     const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the XML Writer features</term>
<listitem><programlisting>
int
raptor_xml_writer_features_enumerate(const raptor_feature feature,
                                     const char **name,
                                     raptor_uri **uri,
                                     const char **label);
</programlisting></listitem>
</varlistentry>
</variablelist>

<para>These functions can be called directly after
<link linkend="raptor-init"><function>raptor_init()</function></link>
has been called so can be used to find name parameters for creating
parser and serializer instances.  This is one way to find a parser
(name) by it's MIME Type, the other is to use the mime_type parameter
of the
<link linkend="raptor-new-parser-for-content"><function>raptor_new_parser_for_content()</function></link>.</para>

<example>
<title>List all features of parsers with an enumerate function</title>
<programlisting>
  int i;
  for(i=0; 1; i++) {
    const char *name;
    raptor_uri *uri;
    const char *label;
    if(raptor_features_enumerate((raptor_feature)i, &amp;name, &amp;uri, &amp;label))
      break;
    /* do something with name, uri and label */
  }
</programlisting>
<para>There are more examples of this usage in the source for the
<literal>rapper</literal> utility in <filename>util/rapper.c</filename>.
</para>
</example>

</section>



<section id="parsing">
<title>Parsing syntaxes to RDF Triples</title>

<para>
The sequence is typically to create a parser object, set various
callback and features, start the parsing, send some syntax to the
parser object, finish the parsing and destroy the parser object.
Several parts of this process are optional, including actually using
the triple results, which is useful as a syntax checking process.
</para>


<section>
<title>Create the Parser object</title>

<para>The parser can be created directly from a known name such as
<literal>rdfxml</literal> for the W3C Recommendation RDF/XML syntax:
<programlisting>
  raptor_parser* rdf_parser;

  rdf_parser = raptor_new_parser("rdfxml");
</programlisting>
or the name can be discovered from an <emphasis>enumeration</emphasis>
as discussed in <link linkend="querying-functionality">Querying Functionality</link>
</para>

<para>The parser can also be created by identifying the syntax by a
URI, specifying the syntax by a MIME Type, providng an identifier for
the content such as filename or URI string or giving some initial
content bytes that can be used to guess.
Using the
<link linkend="raptor-new-parser-for-content"><function>raptor_new_parser_for_content()</function></link>
function, all of these can be given as optional parameters, using NULL
or 0 for undefined paramters.  The constructor will then use as much of
this information as possible.
</para>
<example>
<title>Create a parser by identifying the syntax or providing content</title>
<programlisting>
  raptor_parser* rdf_parser;

  /* Create a parser that reads the MIME Type for RDF/XML */
  rdf_parser = raptor_new_parser_for_content(NULL, "application/rdf+xml", NULL, 0, NULL);

  /* Create a parser that can read a syntax identified by the URI
   * for Turtle, which has no registered MIME Type at this date.
   */
  syntax_uri = raptor_new_uri("http://www.dajobe.org/2004/01/turtle/");
  rdf_parser = raptor_new_parser_for_content(syntax_uri, NULL, NULL, 0, NULL);

  /* Create a parser that recognises the identifier */
  rdf_parser = raptor_new_parser_for_content(NULL, NULL, NULL, 0, "foo.rss");

  /* Create a parser that recognises the content in buffer */
  rdf_parser = raptor_new_parser_for_content(NULL, NULL, buffer, len, NULL);
</programlisting>
</example>

<para>Any of the constructor calls can return NULL if no matching
parser could be found, or the construction failed in another way.
</para>

</section>

<section>
<title>Set parser features</title>
<programlisting>
  raptor_set_feature(rdf_parser, feature, 1);
  raptor_set_feature_string(rdf_parser, feature, "abc");
</programlisting>
</section>

<section>
<title>Set RDF triple callback handler</title>
<programlisting>
  void
  triples_handler(void* user_data, const raptor_statement* triple) 
  {
    /* do something with the triple */
  }

  raptor_set_statement_handler(rdf_parser, user_data, triples_handler);
</programlisting>
</section>

<section>
<title>Set other handlers: error, warning, namespace</title>
<programlisting>
  raptor_set_error_handler(rdf_parser, user_data, error_handler);

  raptor_set_warning_handler(rdf_parser, user_data, warning_handler);

  raptor_set_namespace_handler(rdf_parser, user_data, namespaces_handler);
</programlisting>
</section>

<section>
<title>Provide syntax content to parse</title>
<programlisting>
  /* 1) parse a URI */
  raptor_parse_uri(rdf_parser, uri, base_uri)
  /* 2) parse a URI known to be a file URI */
  raptor_parse_file(rdf_parser, file_uri, base_uri)
  /* 3) parse in steps */
  raptor_start_parse(rdf_parser, base_uri);
  while(/* condition */) {
    /* get syntax in string of size string_len bytes */
    raptor_parse_chunk(rdf_parser, string, string_len, 0);
  }
  raptor_parse_chunk(rdf_parser, NULL, 0, 1);
</programlisting>
</section>

<section>
<title>Destroy the parser</title>
<programlisting>
  raptor_free_parser(rdf_parser);
</programlisting>
</section>

</section>

</chapter>

<!--
Local variables:
mode: sgml
sgml-parent-document: ("raptor-docs.xml" "book" "chapter")
End:
-->
