<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="chapter-tutorial">

<title>Tutorial</title>

<section id="tutorial-section-intro">
<title>Introduction</title>

<para>This chapter describes how to use the
<ulink url="http://librdf.org/raptor/">Raptor</ulink> APIs to
turn syntaxes into RDF triples and RDF triples into syntaxes.</para>

<para>The next chapter contains the
<link linkend="chapter-reference-manual">Raptor Reference Manual</link>
which comprehensively describes every class and function of the API.
</para>

<para>For the latest information, see the
<ulink url="http://librdf.org/raptor/">Raptor Home Page</ulink>
and the <ulink url="../README.html">main document overview</ulink>
in this document tree.
</para>
</section>

<section id="tutorial-initialising-finishing">
<title>Initialising and Finishing using the Library</title>

<para>Raptor has a single initialising function and a single
terminating function.  The initialising function must be called
before any other Raptor API functions are called:
<programlisting>
  raptor_init();
  ...
  raptor_finish();
</programlisting>
</para>

<para>It is safe to call these functions more than once.  But don't
do that!</para>

</section>


<section id="tutorial-querying-functionality">
<title>Listing built-in functionality</title>

<para>
Raptor can be configured and compiled with support for different
parsers and serializers.  Lists of the functionality built into the
library can be interrogated by means of
<emphasis>enumerate</emphasis> functions.  These take as input an
<literal>int</literal> counter and return descriptions of the feature
at that offset in the list.  The descriptions are returned stored in
the variables pointed to by the reference arguments of the
<literal>**</literal><emphasis>var</emphasis> form.
The return value of the function is non-zero when the counter has
gone too far.
</para>

<variablelist>
<title>Listing Functionality with Enumeration</title>
<varlistentry><term>List the parse syntaxes (parser names)</term>
<listitem><programlisting>
int
raptor_parsers_enumerate(const unsigned int counter,
                         const char **name, const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the parse syntaxes
(same as above but with more information)</term>
<listitem><programlisting>
int
raptor_syntaxes_enumerate(const unsigned int counter,
                          const char **name,
                          const char **label, 
                          const char **mime_type,
                          const unsigned char **uri_string);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the serializer syntaxes (serializer names)</term>
<listitem><programlisting>
int
raptor_serializers_enumerate(const unsigned int counter,
                             const char **name,
                             const char **label,
                             const char **mime_type,
                             const unsigned char **uri_string);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the Parser features</term>
<listitem><programlisting>
int
raptor_features_enumerate(const raptor_feature feature,
                          const char **name, raptor_uri **uri,
                          const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the Serializer features</term>
<listitem><programlisting>
int
raptor_serializer_features_enumerate(const raptor_feature feature,
                                     const char **name,
                                     raptor_uri **uri,
                                     const char **label);
</programlisting></listitem>
</varlistentry>
<varlistentry><term>List the XML Writer features</term>
<listitem><programlisting>
int
raptor_xml_writer_features_enumerate(const raptor_feature feature,
                                     const char **name,
                                     raptor_uri **uri,
                                     const char **label);
</programlisting></listitem>
</varlistentry>
</variablelist>

<para>These functions can be called directly after
<link linkend="raptor-init"><function>raptor_init()</function></link>
has been called so can be used to find name parameters for creating
parser and serializer instances.  This is one way to find a parser
(name) by it's MIME Type, the other is to use the mime_type parameter
of the
<link linkend="raptor-new-parser-for-content"><function>raptor_new_parser_for_content()</function></link>.</para>

<example>
<title>List all features of parsers with an enumerate function</title>
<programlisting>
  int i;
  for(i=0; 1; i++) {
    const char *name;
    raptor_uri *uri;
    const char *label;
    if(raptor_features_enumerate((raptor_feature)i, &amp;name, &amp;uri, &amp;label))
      break;
    /* do something with name, uri and label */
  }
</programlisting>
<para>There are more examples of this usage in the source for the
<literal>rapper</literal> utility in <filename>util/rapper.c</filename>.
</para>
</example>

</section>



<section id="tutorial-parsing">
<title>Parsing syntaxes to RDF Triples</title>

<section>
<title>Parsing syntaxes to RDF Triples</title>

<para>
The sequence is typically to create a parser object, set various
callback and features, start the parsing, send some syntax to the
parser object, finish the parsing and destroy the parser object.
Several parts of this process are optional, including actually using
the triple results, which is useful as a syntax checking process.
</para>
</section>

<section>
<title>Create the Parser object</title>

<para>The parser can be created directly from a known name such as
<literal>rdfxml</literal> for the W3C Recommendation RDF/XML syntax:
<programlisting>
  raptor_parser* rdf_parser;

  rdf_parser = raptor_new_parser("rdfxml");
</programlisting>
or the name can be discovered from an <emphasis>enumeration</emphasis>
as discussed in <link linkend="tutorial-querying-functionality">Querying Functionality</link>
</para>

<para>The parser can also be created by identifying the syntax by a
URI, specifying the syntax by a MIME Type, providng an identifier for
the content such as filename or URI string or giving some initial
content bytes that can be used to guess.
Using the
<link linkend="raptor-new-parser-for-content"><function>raptor_new_parser_for_content()</function></link>
function, all of these can be given as optional parameters, using NULL
or 0 for undefined paramters.  The constructor will then use as much of
this information as possible.
</para>
<programlisting>
  raptor_parser* rdf_parser;
</programlisting>

<para>Create a parser that reads the MIME Type for RDF/XML
<literal>application/rdf+xml</literal>
<programlisting>
  rdf_parser = raptor_new_parser_for_content(NULL, "application/rdf+xml", NULL, 0, NULL);
</programlisting>
</para>

<para>Create a parser that can read a syntax identified by the URI
for Turtle <literal>http://www.dajobe.org/2004/01/turtle/</literal>,
which has no registered MIME Type at this date:
<programlisting>
  syntax_uri = raptor_new_uri("http://www.dajobe.org/2004/01/turtle/");
  rdf_parser = raptor_new_parser_for_content(syntax_uri, NULL, NULL, 0, NULL);
</programlisting>
</para>

<para>Create a parser that recognises the identifier <literal>foo.rss</literal>:
<programlisting>
  rdf_parser = raptor_new_parser_for_content(NULL, NULL, NULL, 0, "foo.rss");
</programlisting>
</para>

<para>Create a parser that recognises the content in <emphasis>buffer</emphasis>:
<programlisting>
  rdf_parser = raptor_new_parser_for_content(NULL, NULL, buffer, len, NULL);
</programlisting>
</para>

<para>Any of the constructor calls can return NULL if no matching
parser could be found, or the construction failed in another way.
</para>

</section>


<section>
<title>Set parser features</title>

<para>There are several options that can be set on parsers, called
<emphasis>features</emphasis>.  The exact list of features can be
found via
<link linkend="tutorial-querying-functionality">Querying Functionality</link>
or in the API reference for 
<link linkend="raptor-set-feature"><function>raptor_set_feature()</function></link>.  (This should be properly called raptor_parser_set_feature as
it only applies to <literal>raptor_parser</literal> objects).
</para>

<para>Features are integer enumerations of the
<link linkend="raptor-feature"><type>raptor_feature</type></link> enum and have values
that are either integers (often acting as booleans) or strings.
The two functions that set features are:
<programlisting>
  /* Set an integer (or boolean) valued feature */
  raptor_set_feature(rdf_parser, feature, 1);

  /* Set a string valued feature */
  raptor_set_feature_string(rdf_parser, feature, "abc");
</programlisting>
</para>

</section>

<section>
<title>Set RDF triple callback handler</title>

<para>The main reason to parse a syntax is to get RDF triples
returned and this is done by a callback function which is called
with parameters of a user data pointer and the triple itself.
The handler is set with
<link linkend="raptor-set-statement-handler"><function>raptor_set_statement_handler()</function></link>
as follows:
<programlisting>
  void
  triples_handler(void* user_data, const raptor_statement* triple) 
  {
    /* do something with the triple */
  }

  raptor_set_statement_handler(rdf_parser, user_data, triples_handler);
</programlisting>
</para>

<para>It is optional to set a handler function for triples, which does
have some uses if just counting triples or validating a syntax.
</para>
</section>

<section>
<title>Set fatal error, error and warning handlers</title>

<para>There are several other callback handlers that can be set
on parsers.  These can be set any time before parsing is called.
Errors and warnings from parsing can be returned with functions
that all take a callback of type
<link linkend="raptor-message-handler"><type>raptor_message_handler</type></link>
and signature:
<programlisting>
void
message_handler(void *user_data, raptor_locator* locator, 
                const char *message)
{
  /* do something with the message */
}
</programlisting>
returning the user data given, associated location information
as a <link linkend="raptor-locator"><type>raptor_locator</type></link>
and the error/warning message itself.  The <emphasis>locator</emphasis>
structure contains full information on the details of where in the
file or URI the message occurred.
</para>

<para>The fatal error, error and warning handlers are all set with
similar functions that take a handler as follows:
<programlisting>
  raptor_set_fatal_error_handler(rdf_parser, user_data, fatal_handler);

  raptor_set_error_handler(rdf_parser, user_data, error_handler);

  raptor_set_warning_handler(rdf_parser, user_data, warning_handler);
</programlisting>
<note>The program will terminate
with <function>abort()</function> if the fatal error handler returns.
</note>
</para>
</section>


<section>
<title>Set the identifier creator handler</title>

<para>This is used to customize how identifiers are made
for certain parsers, such as in RDF/XML for generated blank node identifiers as well 
as those from <literal>rdf:nodeID</literal>.
This handler allows the identifier generation mechanism to be
fully replaced.  An alternative is to use
<link linkend="raptor-set-default-generate-id-parameters"><function>raptor_set_default_generate_id_parameters()</function></link>
to adjust the default algorithm for generated identifiers.
</para>

<para>It is used as follows
<programlisting>
  raptor_generate_id_handler id_handler;

  raptor_set_generate_id_handler(rdf_parser, user_data, id_handler);
</programlisting>
</para>

<para>The <emphasis>id_handler</emphasis> takes the following signature:
<programlisting>
unsigned char*
generate_id_handler(void* user_data, raptor_genid_type type,
                    unsigned char* user_id) {
   /* return a new generated ID based on user_id (optional) */
}
</programlisting>
where the
<link linkend="raptor-genid-type"><type>raptor_genid_type</type></link>
provides extra information on the identifier being created and
<emphasis>user_id</emphasis> an optional user-supplied identifier,
such as the value of a <literal>rdf:nodeID</literal> in RDF/XML.
</para>

</section>


<section>
<title>Set namespace declared handler</title>

<para>This allows the tracking of declarations of namespaces
during parsing of a syntax.  
<programlisting>
  raptor_namespace_handler namespaces_handler;

  raptor_set_namespace_handler(rdf_parser, user_data, namespaces_handler);
</programlisting>
</para>

<para>The <emphasis>namespaces_handler</emphasis> takes the following signature:
<programlisting>
void
namespaces_handler(void* user_data, raptor_namespace *nspace) {
  /*  */
}
</programlisting>
<note>This may be called multiple times with the same namespace,
if the namespace is declared inside different XML sub-trees.
</note>
</para>

</section>


<section>
<title>Provide syntax content to parse</title>

<para>There are three alternatives in how to run the actual
operation of turning syntax into triples.</para>

<para>FIXME parse the content of a retrieval from a URI</para>
<programlisting>
  raptor_parse_uri(rdf_parser, uri, base_uri)
</programlisting>

<para>FIXME parse the content from a URI known to be a file</para>
<programlisting>
  raptor_parse_file(rdf_parser, file_uri, base_uri)
</programlisting>

<para>FIXME parse chunks of content
<programlisting>
  raptor_start_parse(rdf_parser, base_uri);
  while(/* not finished getting all content */) {
    unsigned char *buffer;
    size_t buffer_len;
    /* obtain some syntax content in buffer of size buffer_len bytes */
    raptor_parse_chunk(rdf_parser, buffer, buffer_len, 0);
  }
  raptor_parse_chunk(rdf_parser, NULL, 0, 1);
</programlisting>
On the last <function>raptor_parse_chunk()</function> call, or after
the loop is ended, the <literal>is_end</literal> parameter must be
set to non-0.  Content can also be passed with this final call or
NULL given if it is finished.  </para>

</section>

<section>
<title>Destroy the parser</title>
<programlisting>
  raptor_free_parser(rdf_parser);
</programlisting>
</section>

<example>
<title><filename>rdfprint.c</filename>: Parse an RDF/XML file and print the triples</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;raptor.h&gt;

void
print_triple(void* user_data, const raptor_statement* triple) 
{
  raptor_print_statement_as_ntriples(triple, stdout);
  fputc('\n', stdout);
}

int
main(int argc, char *argv[])
{
  raptor_parser* rdf_parser;
  unsigned char *uri_string;
  raptor_uri *uri, *base_uri;

  raptor_init();

  rdf_parser=raptor_new_parser("rdfxml");

  raptor_set_statement_handler(rdf_parser, NULL, print_triple);

  uri_string=raptor_uri_filename_to_uri_string(argv[1]);
  uri=raptor_new_uri(uri_string);
  base_uri=raptor_uri_copy(uri);

  raptor_parse_file(rdf_parser, uri, base_uri);

  raptor_free_uri(uri);
  raptor_free_uri(base_uri);
  raptor_free_parser(rdf_parser);

  raptor_finish();
}
</programlisting>

<para>Compile it like this:
<programlisting>
  gcc -o rdfprint rdfprint.c `raptor-config --cflags` `raptor-config --libs`
</programlisting>
and run it on an RDF file as:
<programlisting>
  ./rdfprint ../raptor.rdf
_:genid1 &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://usefulinc.com/ns/doap#Project&gt; .
_:genid1 &lt;http://usefulinc.com/ns/doap#name&gt; "Raptor" .
_:genid1 &lt;http://usefulinc.com/ns/doap#homepage&gt; &lt;http://librdf.org/raptor/&gt; .
...
</programlisting>
</para>

</example>

</section>

</chapter>


<!--
Local variables:
mode: sgml
sgml-parent-document: ("raptor-docs.xml" "book" "part")
End:
-->
